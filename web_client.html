<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Entanglement Distillation Game – Web Client</title>
    <script src="https://unpkg.com/cytoscape@3.30.3/dist/cytoscape.min.js"></script>
    <style>
      :root {
        --bg: #0b1020;
        --panel: rgba(255, 255, 255, 0.06);
        --panel2: rgba(255, 255, 255, 0.09);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.68);
        --border: rgba(255, 255, 255, 0.14);
        --good: #4caf50;
        --bonus: #ffeb3b;
        --claim: #ff9800;
        --bad: #e53935;
        --blue: #2196f3;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: radial-gradient(1200px 600px at 20% 0%, rgba(102, 126, 234, 0.22), transparent 60%),
          radial-gradient(900px 500px at 80% 10%, rgba(236, 72, 153, 0.18), transparent 55%),
          var(--bg);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }
      .app {
        display: grid;
        grid-template-columns: 360px 1fr;
        height: 100vh;
        gap: 14px;
        padding: 14px;
        box-sizing: border-box;
        overflow: hidden;
      }
      .card {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 14px;
        backdrop-filter: blur(10px);
      }
      .sidebar {
        overflow: auto;
      }
      .mapCard {
        display: flex;
        flex-direction: column;
        min-height: 0; /* critical: allow children to flex without growing page */
        overflow: hidden;
      }
      .title {
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.2px;
        margin: 0 0 10px 0;
      }
      .subtle {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 10px 0 6px 0;
      }
      input,
      select,
      textarea {
        width: 100%;
        box-sizing: border-box;
        background: rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.16);
        color: var(--text);
        padding: 10px 10px;
        border-radius: 12px;
        outline: none;
      }
      textarea {
        resize: vertical;
        min-height: 66px;
      }
      button {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
        color: var(--text);
        cursor: pointer;
        font-weight: 650;
      }
      button:hover {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.08));
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btnRow {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }
      .pillRow {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }
      .pill {
        padding: 10px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.18);
      }
      .pill strong {
        display: block;
        font-size: 12px;
        color: var(--muted);
        font-weight: 650;
      }
      .pill span {
        display: block;
        font-size: 16px;
        font-weight: 800;
        margin-top: 2px;
      }
      #cy {
        flex: 1 1 auto;
        min-height: 0;
        height: auto;
        border-radius: 16px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.18);
      }
      .footerBar {
        margin-top: 10px;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.18);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .hint {
        margin-top: 10px;
        padding: 10px;
        border-radius: 12px;
        border: 1px dashed rgba(255, 255, 255, 0.18);
        color: var(--muted);
        font-size: 12px;
      }
      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
          grid-template-rows: auto 1fr;
        }
        #cy {
          min-height: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="card sidebar">
        <h2 class="title">Web Client</h2>
        <div class="subtle">
          Runs in-browser (desktop/mobile). Your token is stored locally in this browser only.
        </div>

        <label>API Base URL</label>
        <input id="baseUrl" value="https://demo-entanglement-distillation-qfhvrahfcq-uc.a.run.app" />
        <div class="subtle" style="margin-top: 8px">
          <label style="margin: 0; display: inline-flex; gap: 8px; align-items: center">
            <input id="useProxy" type="checkbox" style="width: auto; margin: 0" />
            Use same-origin proxy (recommended)
          </label>
        </div>

        <label>Player ID</label>
        <input id="playerId" placeholder="e.g. 441146" />

        <label>Name</label>
        <input id="playerName" placeholder="e.g. koiboi" />

        <label>API Token (for existing account)</label>
        <input id="apiToken" placeholder="paste from session.json (optional)" />

        <label>Location</label>
        <select id="location">
          <option value="remote">remote</option>
          <option value="in_person">in_person</option>
        </select>

        <div class="btnRow">
          <button id="btnRegister">Register / Login</button>
          <button id="btnLogout">Sign out</button>
        </div>

        <label>Starting node</label>
        <select id="startingNodeSelect" disabled></select>
        <div class="btnRow">
          <button id="btnSelectStart" disabled>Select start</button>
          <button id="btnRestart" disabled>Reset</button>
        </div>

        <div class="pillRow">
          <div class="pill">
            <strong>Score</strong>
            <span id="score">—</span>
          </div>
          <div class="pill">
            <strong>Budget</strong>
            <span id="budget">—</span>
          </div>
        </div>

        <label>View center</label>
        <input id="centerNode" placeholder="click a node…" />
        <label>Radius (hops)</label>
        <select id="radius">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>
        <div class="btnRow">
          <button id="btnSync" disabled>Sync</button>
          <button id="btnClearSel" disabled>Clear selection</button>
        </div>

        <div class="hint">
          - Tap/drag to pan, pinch/scroll to zoom.<br />
          - Tap an orange edge to select it, then press Attack.<br />
          - Green nodes are yours (in <code>owned_nodes</code>). Yellow nodes have bonus budget.
        </div>

        <div class="footerBar" id="statusLog">Not logged in.</div>
      </div>

      <div class="card mapCard" style="padding: 10px">
        <div id="cy"></div>
        <div class="btnRow" style="margin-top: 10px">
          <button id="btnAttack" disabled>Attack selected edge</button>
          <button id="btnAutoLayout" disabled>Re-layout</button>
        </div>
      </div>
    </div>

    <script>
      // ---------------------------
      // Local storage keys
      // ---------------------------
      const LS_KEY = "ionq2026_webclient_v1";

      // ---------------------------
      // DOM helpers
      // ---------------------------
      const $ = (id) => document.getElementById(id);
      const logEl = $("statusLog");
      const setLog = (msg) => (logEl.textContent = msg);

      // ---------------------------
      // API helpers
      // ---------------------------
      async function apiGet(baseUrl, path, token) {
        const useProxy = $("useProxy")?.checked && window.location.protocol !== "file:";
        const url = useProxy
          ? `/api/proxy?path=${encodeURIComponent(path)}&base=${encodeURIComponent(baseUrl)}`
          : baseUrl.replace(/\/$/, "") + path;
        let r;
        try {
          r = await fetch(url, {
            method: "GET",
            headers: token ? { Authorization: `Bearer ${token}` } : {},
          });
        } catch (e) {
          throw new Error(
            'Failed to fetch. If you see a CORS error, run "python proxy_server.py" and open http://localhost:5173/web_client.html (or deploy to Vercel with /api/proxy).'
          );
        }
        const j = await r.json().catch(() => ({}));
        if (!r.ok) throw new Error((j.error && j.error.message) || `HTTP ${r.status}`);
        return j.data || {};
      }

      async function apiPost(baseUrl, path, token, payload) {
        const useProxy = $("useProxy")?.checked && window.location.protocol !== "file:";
        const url = useProxy
          ? `/api/proxy?path=${encodeURIComponent(path)}&base=${encodeURIComponent(baseUrl)}`
          : baseUrl.replace(/\/$/, "") + path;
        let r;
        try {
          r = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...(token ? { Authorization: `Bearer ${token}` } : {}),
            },
            body: JSON.stringify(payload),
          });
        } catch (e) {
          throw new Error(
            'Failed to fetch. If you see a CORS error, run "python proxy_server.py" and open http://localhost:5173/web_client.html (or deploy to Vercel with /api/proxy).'
          );
        }
        const j = await r.json().catch(() => ({}));
        if (!r.ok) throw new Error((j.error && j.error.message) || `HTTP ${r.status}`);
        return j;
      }

      // ---------------------------
      // QASM generators (no Qiskit)
      // ---------------------------
      // IMPORTANT: The game server is picky about QASM3 syntax.
      // These QASM strings are copied from Qiskit's `qasm3.dumps(...)` output for the
      // circuits in `distillation_circuits.py` (same logic, same formatting).
      const QASM_BY_DIFFICULTY = {
        1: {
          num_bell_pairs: 2,
          flag_bit: 2,
          qasm: `OPENQASM 3.0;
include "stdgates.inc";
bit[3] c;
qubit[4] q;
cx q[1], q[0];
cx q[2], q[3];
c[0] = measure q[0];
c[1] = measure q[3];
c[2] = c[0] ^ c[1];
`,
        },
        2: {
          num_bell_pairs: 2,
          flag_bit: 2,
          qasm: `OPENQASM 3.0;
include "stdgates.inc";
bit[3] c;
qubit[4] q;
h q[0];
h q[1];
h q[2];
h q[3];
cx q[1], q[0];
cx q[2], q[3];
c[0] = measure q[0];
c[1] = measure q[3];
h q[1];
h q[2];
c[2] = c[0] ^ c[1];
`,
        },
        3: {
          num_bell_pairs: 3,
          flag_bit: 6,
          qasm: `OPENQASM 3.0;
include "stdgates.inc";
bit[7] c;
qubit[6] q;
cx q[2], q[0];
cx q[3], q[5];
cx q[2], q[1];
cx q[3], q[4];
c[0] = measure q[0];
c[1] = measure q[1];
c[2] = measure q[5];
c[3] = measure q[4];
c[4] = c[0] ^ c[2];
c[5] = c[1] ^ c[3];
c[6] = c[4] | c[5];
`,
        },
        4: {
          num_bell_pairs: 3,
          flag_bit: 6,
          qasm: `OPENQASM 3.0;
include "stdgates.inc";
bit[7] c;
qubit[6] q;
h q[0];
h q[1];
h q[2];
h q[3];
h q[4];
h q[5];
cx q[2], q[0];
cx q[3], q[5];
cx q[2], q[1];
cx q[3], q[4];
c[0] = measure q[0];
c[1] = measure q[1];
c[2] = measure q[5];
c[3] = measure q[4];
h q[2];
h q[3];
c[4] = c[0] ^ c[2];
c[5] = c[1] ^ c[3];
c[6] = c[4] | c[5];
`,
        },
        5: {
          num_bell_pairs: 5,
          flag_bit: 14,
          qasm: `OPENQASM 3.0;
include "stdgates.inc";
bit[15] c;
qubit[10] q;
h q[4];
h q[5];
h q[1];
h q[8];
h q[0];
h q[9];
cx q[4], q[1];
cx q[5], q[8];
cx q[4], q[0];
cx q[5], q[9];
c[0] = measure q[1];
c[1] = measure q[0];
c[2] = measure q[8];
c[3] = measure q[9];
h q[4];
h q[5];
cx q[4], q[3];
cx q[5], q[6];
cx q[4], q[2];
cx q[5], q[7];
c[4] = measure q[3];
c[5] = measure q[2];
c[6] = measure q[6];
c[7] = measure q[7];
c[8] = c[0] ^ c[2];
c[9] = c[1] ^ c[3];
c[12] = c[8] | c[9];
c[10] = c[4] ^ c[6];
c[11] = c[5] ^ c[7];
c[13] = c[10] | c[11];
c[14] = c[12] | c[13];
`,
        },
      };

      function qasmForDifficulty(diff) {
        const d = QASM_BY_DIFFICULTY[diff];
        if (!d) throw new Error(`No strategy for difficulty ${diff}`);
        return d;
      }

      // ---------------------------
      // State
      // ---------------------------
      const state = {
        baseUrl: $("baseUrl").value,
        apiToken: null,
        playerId: null,
        name: null,
        graph: null,
        status: null,
        startingCandidates: [],
        ownedNodes: new Set(),
        ownedEdges: [],
        selectedEdge: null, // {u,v,diff,thr}
        centerNode: null,
        nodePositions: new Map(), // node_id -> {x,y}
        lastVisibleKey: null,
      };

      function saveLocal() {
        localStorage.setItem(
          LS_KEY,
          JSON.stringify({
            baseUrl: state.baseUrl,
            apiToken: state.apiToken,
            playerId: state.playerId,
            name: state.name,
            centerNode: state.centerNode,
          })
        );
      }

      function loadLocal() {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return;
        try {
          const j = JSON.parse(raw);
          if (j.baseUrl) $("baseUrl").value = j.baseUrl;
          if (j.playerId) $("playerId").value = j.playerId;
          if (j.name) $("playerName").value = j.name;
          if (j.apiToken) state.apiToken = j.apiToken;
          if (j.playerId) state.playerId = j.playerId;
          if (j.name) state.name = j.name;
          if (j.centerNode) state.centerNode = j.centerNode;
          if (j.apiToken) $("apiToken").value = j.apiToken;
        } catch {}
      }

      // ---------------------------
      // Graph rendering
      // ---------------------------
      let cy = null;
      function initCy() {
        if (cy) return;
        cy = cytoscape({
          container: $("cy"),
          elements: [],
          wheelSensitivity: 0.2,
          style: [
            {
              selector: "node",
              style: {
                "background-color": "data(color)",
                label: "data(label)",
                color: "rgba(255,255,255,0.92)",
                "font-size": 9,
                "text-wrap": "wrap",
                "text-max-width": 120,
                "text-outline-width": 2,
                "text-outline-color": "rgba(0,0,0,0.45)",
                width: "data(size)",
                height: "data(size)",
              },
            },
            {
              selector: "edge",
              style: {
                width: "data(width)",
                "line-color": "data(color)",
                "curve-style": "bezier",
                label: "data(label)",
                "font-size": 9,
                color: "rgba(255,255,255,0.85)",
                "text-outline-width": 2,
                "text-outline-color": "rgba(0,0,0,0.50)",
              },
            },
            {
              selector: ".selected",
              style: {
                "line-color": "var(--bad)",
                width: 5,
              },
            },
          ],
          layout: { name: "cose", animate: true, animationDuration: 400, randomize: false },
        });

        cy.on("tap", "node", (evt) => {
          const id = evt.target.id();
          state.centerNode = id;
          $("centerNode").value = id;
          saveLocal();
          render();
        });

        cy.on("tap", "edge", (evt) => {
          const e = evt.target;
          const u = e.data("u");
          const v = e.data("v");
          const claimable = e.data("claimable");
          if (!claimable) return;
          state.selectedEdge = {
            u,
            v,
            diff: e.data("diff"),
            thr: e.data("thr"),
          };
          $("btnAttack").disabled = false;
          $("btnClearSel").disabled = false;
          setLog(`Selected edge: ${u} <-> ${v} | D${state.selectedEdge.diff} | thr=${state.selectedEdge.thr}`);
          cy.edges().removeClass("selected");
          e.addClass("selected");
        });
      }

      function adjacency() {
        const adj = new Map();
        for (const e of state.graph.edges || []) {
          const [a, b] = e.edge_id;
          if (!adj.has(a)) adj.set(a, []);
          if (!adj.has(b)) adj.set(b, []);
          adj.get(a).push(b);
          adj.get(b).push(a);
        }
        return adj;
      }

      // Stable, collision-resistant undirected edge key for Cytoscape IDs / sets.
      // We URI-encode node ids so separators can’t collide with city names.
      function edgeKey(a, b) {
        const x = String(a);
        const y = String(b);
        const u = x <= y ? x : y;
        const v = x <= y ? y : x;
        return `${encodeURIComponent(u)}__${encodeURIComponent(v)}`;
      }

      function neighborhood(center, r) {
        if (!center) return new Set();
        const adj = adjacency();
        const seen = new Set([center]);
        let frontier = new Set([center]);
        for (let i = 0; i < r; i++) {
          const next = new Set();
          for (const u of frontier) {
            for (const v of adj.get(u) || []) next.add(v);
          }
          for (const v of next) seen.add(v);
          frontier = next;
        }
        return seen;
      }

      function buildClaimableUndirected() {
        const owned = state.ownedNodes;
        const claim = new Set();
        for (const e of state.graph.edges || []) {
          const [a, b] = e.edge_id;
          if ((owned.has(a) ? 1 : 0) ^ (owned.has(b) ? 1 : 0)) {
            claim.add(edgeKey(a, b));
          }
        }
        return claim;
      }

      function render() {
        if (!state.graph) return;
        initCy();

        // Save current positions so we don't "forget" layout every redraw.
        try {
          if (cy && cy.nodes) {
            cy.nodes().forEach((n) => {
              const id = n.id();
              const p = n.position();
              if (id && Number.isFinite(p.x) && Number.isFinite(p.y)) state.nodePositions.set(id, { x: p.x, y: p.y });
            });
          }
        } catch {}

        const owned = state.ownedNodes;
        // If the user isn't logged in yet, we still want *something* to render.
        // Pick a stable default center from the graph itself.
        const fallbackCenter =
          (state.graph.nodes && state.graph.nodes.length ? state.graph.nodes[0].node_id : null) || null;
        const center = state.centerNode || state.status?.starting_node || fallbackCenter;
        const r = parseInt($("radius").value, 10);
        const visible = neighborhood(center, r);

        const visibleKey = JSON.stringify(Array.from(visible).sort());
        const visibleChanged = state.lastVisibleKey !== visibleKey;
        state.lastVisibleKey = visibleKey;

        const claimable = buildClaimableUndirected();

        const nodeData = new Map();
        for (const n of state.graph.nodes || []) nodeData.set(n.node_id, n);

        const elements = [];
        for (const id of visible) {
          const nd = nodeData.get(id) || {};
          const uq = nd.utility_qubits ?? 0;
          const bonus = nd.bonus_bell_pairs ?? 0;
          const isOwned = owned.has(id);
          const color = isOwned ? "#4CAF50" : bonus > 0 ? "#FFEB3B" : "#2196F3";
          const label = `${id}\\n+${uq}${!isOwned && bonus > 0 ? ` (+${bonus}B)` : ""}`;
          const size = 20 + Math.min(50, uq * 6);
          elements.push({ data: { id, label, color, size } });
        }

        for (const e of state.graph.edges || []) {
          const [a, b] = e.edge_id;
          if (!visible.has(a) || !visible.has(b)) continue;
          const key = edgeKey(a, b);
          const isClaimable = claimable.has(key);
          const isOwnedEdge = false; // server doesn't expose in /graph; keep simple
          const color = isClaimable ? "#FF9800" : isOwnedEdge ? "#4CAF50" : "#9E9E9E";
          const width = isClaimable ? 3 : 1;
          const label = `D${e.difficulty_rating ?? "?"}`;
          const id = `e:${key}`;
          elements.push({
            data: {
              id,
              source: a,
              target: b,
              u: a,
              v: b,
              color,
              width,
              label,
              claimable: isClaimable,
              diff: e.difficulty_rating ?? null,
              thr: e.base_threshold ?? null,
            },
          });
        }

        cy.elements().remove();
        cy.add(elements);

        // Restore known node positions (stability), then only re-layout when the visible subgraph changed.
        try {
          cy.nodes().forEach((n) => {
            const p = state.nodePositions.get(n.id());
            if (p) n.position(p);
          });
        } catch {}

        // Layout: auto-run when new nodes appear / radius changes / recenter reveals a new neighborhood.
        if (!cy.scratch("_laidOut") || visibleChanged) {
          cy.layout({ name: "cose", animate: true, animationDuration: 420, randomize: false }).run();
          cy.scratch("_laidOut", true);
        }

        // Always fit the current neighborhood nicely.
        cy.fit(undefined, 30);

        // keep selection highlight if still visible
        if (state.selectedEdge) {
          const key = edgeKey(state.selectedEdge.u, state.selectedEdge.v);
          const edge = cy.getElementById(`e:${key}`);
          if (edge && edge.length) {
            cy.edges().removeClass("selected");
            edge.addClass("selected");
          } else {
            state.selectedEdge = null;
            $("btnAttack").disabled = true;
          }
        }
      }

      // ---------------------------
      // Game actions
      // ---------------------------
      async function loadGraphOnce() {
        if (state.graph) return;
        state.baseUrl = $("baseUrl").value.trim();
        setLog("Loading graph… (this endpoint can take ~60s)");
        state.graph = await apiGet(state.baseUrl, "/v1/graph", null);
        setLog("Graph loaded.");

        // If we haven't centered yet, center now so the initial render isn't blank.
        if (!state.centerNode && state.graph.nodes && state.graph.nodes.length) {
          state.centerNode = state.graph.nodes[0].node_id;
          $("centerNode").value = state.centerNode || "";
          saveLocal();
        }
      }

      async function syncStatus() {
        if (!state.apiToken || !state.playerId) return;
        state.baseUrl = $("baseUrl").value.trim();
        const s = await apiGet(state.baseUrl, `/v1/status/${encodeURIComponent(state.playerId)}`, state.apiToken);
        state.status = s;
        state.ownedNodes = new Set(s.owned_nodes || []);
        state.ownedEdges = s.owned_edges || [];
        $("score").textContent = s.score ?? 0;
        $("budget").textContent = s.budget ?? 0;
        if (!state.centerNode) {
          state.centerNode = s.starting_node || null;
          $("centerNode").value = state.centerNode || "";
        }
        saveLocal();
        render();
      }

      function setLoggedInUi(on) {
        $("btnSelectStart").disabled = !on;
        $("btnRestart").disabled = !on;
        $("btnSync").disabled = !on;
        $("btnAutoLayout").disabled = !on;
        $("btnClearSel").disabled = !on;
        $("btnAttack").disabled = !on || !state.selectedEdge;
      }

      function populateCandidates(cands) {
        const sel = $("startingNodeSelect");
        sel.innerHTML = "";
        if (!cands || !cands.length) {
          sel.disabled = true;
          return;
        }
        sel.disabled = false;
        for (const c of cands) {
          const opt = document.createElement("option");
          opt.value = c.node_id;
          opt.textContent = `${c.node_id}  (+${c.utility_qubits} pts, +${c.bonus_bell_pairs} budget)`;
          sel.appendChild(opt);
        }
      }

      // ---------------------------
      // Button handlers
      // ---------------------------
      $("btnRegister").addEventListener("click", async () => {
        try {
          state.baseUrl = $("baseUrl").value.trim();
          const pid = $("playerId").value.trim();
          const nm = $("playerName").value.trim();
          const tokenInput = $("apiToken").value.trim();
          const loc = $("location").value;
          if (!pid || !nm) throw new Error("Player ID and Name are required.");

          // If they already have a token (from session.json), allow "login" without registering.
          if (tokenInput) {
            state.apiToken = tokenInput;
            state.playerId = pid;
            state.name = nm;
            $("btnLogout").disabled = false;
            await loadGraphOnce();
            await syncStatus();
            setLoggedInUi(true);
            setLog("Logged in via API token.");
            saveLocal();
            return;
          }

          setLog("Registering…");
          const j = await apiPost(state.baseUrl, "/v1/register", null, { player_id: pid, name: nm, location: loc });

          if (j.ok) {
            state.apiToken = j.data.api_token;
            $("apiToken").value = state.apiToken || "";
            state.playerId = pid;
            state.name = nm;
            $("btnLogout").disabled = false;
            state.startingCandidates = j.data.starting_candidates || [];
            populateCandidates(state.startingCandidates);
            await loadGraphOnce();
            await syncStatus();
            setLoggedInUi(true);
            setLog("Registered. Select a starting node if needed.");
            saveLocal();
            return;
          }

          // If the account already exists, the server typically won't re-issue the token.
          // Tell the user how to log in (paste token from session.json).
          const code = j?.error?.code;
          if (code === "PLAYER_EXISTS") {
            state.playerId = pid;
            state.name = nm;
            setLoggedInUi(false);
            setLog('Player already registered. Paste your API token (from session.json) into "API Token" and press Register / Login again.');
            return;
          }

          throw new Error((j.error && j.error.message) || "Register failed");
        } catch (e) {
          setLog(`Error: ${e.message || e}`);
        }
      });

      $("btnLogout").addEventListener("click", () => {
        state.apiToken = null;
        state.playerId = null;
        state.name = null;
        state.status = null;
        state.ownedNodes = new Set();
        state.selectedEdge = null;
        $("score").textContent = "—";
        $("budget").textContent = "—";
        $("startingNodeSelect").innerHTML = "";
        $("startingNodeSelect").disabled = true;
        setLoggedInUi(false);
        localStorage.removeItem(LS_KEY);
        setLog("Signed out.");
        if (cy) {
          cy.elements().remove();
          cy.scratch("_laidOut", false);
        }
      });

      $("btnSelectStart").addEventListener("click", async () => {
        try {
          if (!state.apiToken || !state.playerId) throw new Error("Not logged in.");
          const nodeId = $("startingNodeSelect").value;
          if (!nodeId) throw new Error("No starting node selected.");
          setLog(`Selecting starting node: ${nodeId}…`);
          const j = await apiPost(state.baseUrl, "/v1/select_starting_node", state.apiToken, { player_id: state.playerId, node_id: nodeId });
          if (!j.ok) throw new Error((j.error && j.error.message) || "Select start failed");
          await syncStatus();
          state.centerNode = nodeId;
          $("centerNode").value = nodeId;
          render();
          setLog("Starting node selected.");
        } catch (e) {
          setLog(`Error: ${e.message || e}`);
        }
      });

      $("btnRestart").addEventListener("click", async () => {
        try {
          if (!state.apiToken || !state.playerId) throw new Error("Not logged in.");
          if (!confirm("Reset account? This restarts your game progress.")) return;
          setLog("Resetting…");
          const j = await apiPost(state.baseUrl, "/v1/restart", state.apiToken, { player_id: state.playerId });
          if (!j.ok) throw new Error((j.error && j.error.message) || "Restart failed");
          // After restart, you must select a starting node again. Candidates may persist server-side.
          state.selectedEdge = null;
          $("btnAttack").disabled = true;
          await syncStatus();
          setLog("Reset done. Select a starting node again.");
        } catch (e) {
          setLog(`Error: ${e.message || e}`);
        }
      });

      $("btnSync").addEventListener("click", async () => {
        try {
          setLog("Syncing…");
          await loadGraphOnce();
          await syncStatus();
          setLog("Synced.");
        } catch (e) {
          setLog(`Error: ${e.message || e}`);
        }
      });

      $("btnClearSel").addEventListener("click", () => {
        state.selectedEdge = null;
        $("btnAttack").disabled = true;
        setLog("Selection cleared.");
        if (cy) cy.edges().removeClass("selected");
      });

      $("btnAutoLayout").addEventListener("click", () => {
        if (!cy) return;
        cy.scratch("_laidOut", false);
        cy.layout({ name: "cose", animate: true, animationDuration: 450, randomize: true }).run();
        cy.scratch("_laidOut", true);
      });

      $("btnAttack").addEventListener("click", async () => {
        try {
          if (!state.apiToken || !state.playerId) throw new Error("Not logged in.");
          if (!state.selectedEdge) throw new Error("No edge selected.");
          const { u, v, diff } = state.selectedEdge;
          const strat = qasmForDifficulty(Number(diff));
          setLog(`Attacking ${u} <-> ${v} with D${diff}…`);
          const prevOwned = new Set(state.ownedNodes);
          const payload = {
            player_id: state.playerId,
            edge: [u, v],
            num_bell_pairs: strat.num_bell_pairs,
            circuit_qasm: strat.qasm,
            flag_bit: strat.flag_bit,
          };
          const j = await apiPost(state.baseUrl, "/v1/claim_edge", state.apiToken, payload);
          if (!j.ok) throw new Error((j.error && j.error.message) || "Claim failed");
          const data = j.data || {};
          setLog(`Result: success=${data.success} F=${data.fidelity?.toFixed?.(4) ?? data.fidelity} p=${data.success_probability?.toFixed?.(4) ?? data.success_probability}`);
          await syncStatus();

          // If this captured a new node, auto-center on it so the neighborhood expands naturally.
          const newOwned = Array.from(state.ownedNodes).filter((n) => !prevOwned.has(n));
          if (data.success && newOwned.length) {
            state.centerNode = newOwned[0];
            $("centerNode").value = state.centerNode;
            saveLocal();
            render();
          }
        } catch (e) {
          setLog(`Error: ${e.message || e}`);
        }
      });

      // UI changes
      $("radius").addEventListener("change", () => render());
      $("centerNode").addEventListener("change", () => {
        state.centerNode = $("centerNode").value.trim() || null;
        saveLocal();
        render();
      });

      // Boot
      (async () => {
        loadLocal();
        state.baseUrl = $("baseUrl").value.trim();
        state.playerId = $("playerId").value.trim() || null;
        state.name = $("playerName").value.trim() || null;
        setLoggedInUi(false);
        // Default proxy ON when served from a real origin (localhost/Vercel),
        // because the upstream API often doesn't allow browser CORS.
        if ($("useProxy")) $("useProxy").checked = window.location.protocol !== "file:";

        try {
          await loadGraphOnce();
          // Always render the public graph view (even before login),
          // so users can explore the map immediately.
          render();
          if (state.apiToken && state.playerId) {
            setLog("Restoring session…");
            $("btnLogout").disabled = false;
            setLoggedInUi(true);
            await syncStatus();
            setLog("Session restored. Sync when needed.");
          } else {
            setLog('Graph loaded. Now "Register / Login" to play.');
          }
        } catch (e) {
          setLog(`Startup error: ${e.message || e}`);
        }
      })();
    </script>
  </body>
</html>

